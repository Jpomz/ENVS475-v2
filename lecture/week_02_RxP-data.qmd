---
title: "Lecture Week 02: Intro"
format: 
  html:
    embed-resources: true
editor: visual
toc: true
toc-depth: 3
number-sections: true
theme:
  light: flatly
  dark: darkly
---

```{r}
#| label: setup
#| include: false

library(tidyverse)

rxp <- read.csv(here::here("data/RxP.csv"), stringsAsFactors = TRUE)
```

# Overview

-   Introduce R, R Studio

-   Basic programming

-   Working with objects in R

-   Functions

-   `RxP.csv` data

-   Data exploration, visualization, and manipulation

# Setup

### Libraries

```{r}
#| eval: false
library(tidyverse)
```

### Data

-   `RxP.csv` data

    -   available [here](https://global.oup.com/booksites/fdscontent/booksites/uk/booksites/content/9780198869979/RxP.csv)

-   Download the data and put it into your `data/` folder.

```{r}
#| eval: false
rxp <- read.csv("data/RxP.csv",
                stringsAsFactors = TRUE)
```

# Lecture Outline

-   R is the engine, R Studio is the car

    -   Always open R Studio icon

    -   Check that you are in your ENVS475 project

        -   Top right of R Studio

-   Basic expressions

    -   R is a calculator

```{r}
2+2

3 / 2
```

-   In the notes, Code blocks look like this:

```{r}
#| eval: false

2 + 2
```

-   and Output looks like this

```{r}
#| echo: false
2 + 2
```

### Commenting your code

-   Use `#` at the front of a line of code to write notes to your self

-   The `#` is used to create a "comment"

-   R sees the `#` and ignores everything that comes after it

```{r}
# how many times does 3 go into 100?
100/3
```

-   Use comments judiciously to take notes and remind yourself what you're doing

    -   Especially while you're learning

    -   Later, try and only leave yourself notes to explain *WHY* you're doing things, not *WHAT* you're doing.

## Objects

-   We can store objects in R to use them later

```{r}
x <- 3
```

-   the `<-` is called the assign operator

    -   shortcut: Windows = `ctrl` + `-`

    -   Mac = `option` + `-`

-   Check environment

    -   `x` now has the value of 3

-   Can use `x` in calculations

```{r}
x / 3
x + 3
```

-   The value of x does not change unless we re-assign it

```{r}
x
x <- x + 3
x
```

-   Note than when we assign a value, it does *not* show us the output in the console
-   Need to type `x` again to see what the new value is

## Data modes

-   R has different classes, or modes that data can be stored in

-   `x` above was a numeric mode

```{r}
mode(x)
```

-   Other types include:

    -   `character`: text

        -   Note that numbers can be stored as text OR numeric

    -   `factor`: a special type of `character` mode which can have `levels`

        -   `characters` will automatically be sorted by alphabetical order

        -   with a `factor`, You can set the levels to be in any order you want

    -   `logical`: either `TRUE` or `FALSE`

    -   `numeric`

        -   Note that `numeric` classes can be stored as an `integer` (whole numbers) or as a `double` (includes decimal places)

        -   R generally automatically switches as appropriate

        -   Don't generally have to worry about it, but you should be aware of it

-   Examples of modes

```{r}
y <- "hello"
z <- TRUE
factor_example <- factor("goodbye")
y
z
factor_example
```

-   Check with the `mode()` function
    -   can also check to see if object is a specific mode
    -   i.e., `is.factor()` below
    -   Returns `TRUE` or `FALSE`

```{r}
mode(y)
mode(z)
mode(factor_example)
# note that this is NUMERIC
# this is how the order is stored
is.factor(factor_example)
```

## Types of objects

-   Objects above had a single value stored in it

    -   This is known as a `scalar`

-   Other data types and brief definitions

    -   `vector`: many items in a single dimension, all items have to be the same class (or "mode" in R-speak)

    -   `matrix`: many items in two dimensions (organized in rows and columns), all items have to be the same mode

    -   `data.frame`: Many items in two dimensions. All items in a column have to be the same type, but different columns can have different mode

    -   `list`: An object with many items, where each item can be of any object type, including another list

-   We will be primarily working with `data.frames` and `vectors`

-   The results of most of our statistical tests will be stored as `lists`

## Getting data into R

-   Let's load the `RxP` data into R

-   If you didn't already, run the following code

```{r}
#| eval: false
rxp <- read.csv("data/RxP.csv",
                stringsAsFactors = TRUE)
```

-   This is telling R

    -   Make an object called `rxp`

    -   Make it by using the function `read.csv()`

    -   `read.csv()` does what it sounds like, it reads a csv file

    -   Specifically, we're telling it to

        -   Look in the folder called `data/`

        -   Look for a file called `RxP.csv` in that folder

    -   In addition, we're telling it to make any columns with `character` data (i.e., "strings") to be a `Factor`

        -   This is necessary for a lot of the statistical functions we will use later

-   Now we have a thing called `rxp` and we can work with that object

    -   More about the data structure below

    -   We will go over this again as needed throughout the semester

## Looking at objects

-   R is a functional programming language

    -   We will generally be calling functions to do things

    -   functions always have a name followed by a set or parentheses

    -   Functions will do something and display it in the console

    -   If we want to save the output, we need to use the `<-` operator

-   Let's look at our `rxp` object

    -   `str()` shows us the structure

        -   Tells us the object type (`data.frame`)

        -   Number of rows (obs.) and columns (variables)

        -   `$` is before each column name

        -   After the name, it shows us the mode, and then shows the first few values in those columns

        -   Mode abbreviations:

            -   `int` = integer

            -   `chr` = character

            -   `Factor` = factor

            -   `num` = numeric (i.e., decimal number)

        -   Also note that we will use the `$` to select columns based on name from data frames

```{r}
str(rxp)
```

-   `head()` shows us the first few row of the data (but not the column mode)

    -   Note that it shows us **all** the columns in the console

    -   may need to scroll up to see everything

```{r}
head(rxp)
```

-   `names()` shows us the column names

    -   This is sometimes better than head, especially when there are many columns

```{r}
names(rxp)
```

-   `as_tibble()` is a useful function to know

    -   a `tibble` is a special data frame

    -   Shows us the dimensions (rows and columns) at the top

    -   It only shows the number of columns that easily fit in your window

        -   Extra column names are listed below

    -   It also shows the mode of each column which can be extremely helpful

```{r}
as_tibble(rxp)
```

-   note that `read_csv()` is a modified version of `read.csv()` which automatically reads the file in as a tibble

-   We will use both in class

    -   I generally prefer `read_csv()`

    -   But it does not have an easy way of automatically creating `Factors`

    -   Some of our analyses require `Factors` , so `read.csv()` will be used.

-   Looking at values in a column

    -   Sometimes, particularly with character/factor modes, we want to see all the individual values in a column

-   Use `unique()` or `distinct()`

    -   `unique()` requires a vector

        -   We can extract a single column from a data frame as a vector by using the `$`

    -   With `distinct()`, we supply the data frame and then the name(s) of the columns separated by a `,`

        -   `distinct()` can show us all the unique combinations of multiple variables

```{r}
# extract the `Block` column as a vector
unique(rxp$Block)
# note that this returns a vector

distinct(rxp, Block)
# this returns a one-column data frame

distinct(rxp, Block, Pred) |>
  arrange(Block)
# this shows us that block
# 4, 6, 7, and 8
# only have 2 of the three treatments
```

-   By combining the `Block` and `Pred` columns, we can see that not all the blocks have all Predator treatments in them

    -   The author states that a disease broke out in some tanks, and the data from those were removed.

## Plotting data with `plot()`

### Plotting one variable

-   basic plots using the `plot()` function

-   Plot all the values of one column by "extracting" the column

    -   the `SVL.initial` column records the snout-vent length of individual froglets

```{r}
plot(rxp$SVL.initial)
```

-   This shows every individual SVL.initial measurement in the data

-   The Index is just the number of the row

    -   If we re-sorted the data an individual data point would have a different index

-   The y-axis shows us the individual value

    -   This shows us that the measurements were generally between 14-24 mm

    -   **One individual is very small**

    -   "most" of the individuals are in the "middle" of the data spread

-   Another example of the initial tail length measurement

```{r}
plot(rxp$Tail.initial)
```

-   what does this tell us?

    -   Any **concerning** observations?

-   Plot a factor variable

```{r}
plot(rxp$Pred)
```

-   Since `Pred` is a `factor`, this plot just shows us the number of individuals (rows) in each group

    -   So the control (`C`) treatment had \~1200 individuals, whereas the the non lethal (`NL`) only had \~500 individuals

### Plotting two variables

-   We can see how variables vary together by plotting them both

-   Two options

    -   "extract" both variables, separated by a comma (first one = x, second one = y)

    -   or separate our y and x variables with a `~` and tell the function which object our data is coming from

```{r}
plot(rxp$Pred, rxp$Mass.final)
plot(Mass.final ~ SVL.final, data = rxp)
```

-   first example had a `factor` and a `numeric` variable

    -   R automatically made boxplots to show variation in data by group

-   second example had two `numeric` variables

    -   R made a scatter plot

-   Note that the scatter plot has a "curve" to it

    -   This is commonly seen in biological data

    -   Indicates a non-linear relationship

    -   Common method is to "log-transform" the data

-   Two options for log-transformation

```{r}
plot(log(Mass.final) ~ log(SVL.final), data = rxp)
plot(Mass.final ~ SVL.final, data = rxp, log = "xy")
```

-   **NOTE** the four "heavy" but "short" individuals

-   Jumping ahead - alternatives to log-transformation

    -   Analyzing transformed data is ok and has been done for a long time

    -   There are a number of problems with it

    -   Better alternatives now exist

    -   Later in the class, we will explore these

## Modifying the data

-   The figures above show us that there are 4 individuals with SVL \< 19 and mass \> 0.6 g

    -   In other words, very short, but very heavy individuals

    -   Likely impossible to have this combination

    -   Could have been an error in data entry or something else

    -   We are going to remove these individuals

::: callout-warning
## Outliers

-   Identifying outliers is difficult and subjective

-   You should ***NOT*** remove data just because it doesn't fit or looks weird

-   I generally avoid removing data as much as possible

    -   There are more sophisticated statistical tests which are less sensitive to one or a few extreme values

    -   We will go over some of these briefly later in class

-   Here, we are going to follow the example in the textbook so that our results match those in the book

-   I was not involved in the collection or analysis of this data

-   I am trusting the author who was involved and following their lead.

-   I'm sure the data are being removed for good reasons
:::

-   use the `filter()` command to keep (or discard) certain rows of data

-   Keep all rows where the value in `SVL.final` is less than 19

```{r}
#| eval: false
filter(rxp, SVL.final < 19)
```

```{r}
#| echo: false
filter(rxp, SVL.final < 19) |>
  as_tibble()

```

-   This returns 1300+ rows; That's a lot of data!

-   Let's also only keep the rows where the value in `Mass.final` is also \> 0.6

```{r}
filter(rxp, 
       SVL.final < 19,
       Mass.final > 0.6)
```

-   That's only 4 individuals, which matches our figure above

-   The above code *keeps* these rows and gets rid of everything else

-   But we want to *discard* these rows

    -   In this case, the best way to do this is by using the values in the `Ind` column

    -   Each individual (i.e., row), has a unique `Ind` value

    -   So we can get rid of `Ind` 734, 1024, 1078, and 1284

-   In addition, there is a long individual with very small mass

```{r}
filter(rxp, 
       SVL.final>24,
       Mass.final<0.6)
```

-   Also remove `Ind` 1127

<!-- -->

-   Create a `tmp` (temporary) object to store these results

    -   Note that `!=` is code for "not equal to"

```{r}
tmp <- filter(rxp, 
              Ind != 734,
              Ind != 1024,
              Ind != 1078,
              Ind != 1127,
              Ind != 1284)
dim(tmp)
dim(rxp)
```

-   Store the modified data as `tmp`

-   Check the dimensions using the `dim()` function to check the number of rows

    -   original data had 2502 rows

    -   `tmp` data has 2498 which is 4 fewer

### More `filter()` notes

+--------+-------------------------------------------------------+
| Symbol | Meaning                                               |
+========+=======================================================+
| \<     | is less than                                          |
+--------+-------------------------------------------------------+
| \<=    | is less than or equal to                              |
+--------+-------------------------------------------------------+
| \>     | is greater than                                       |
+--------+-------------------------------------------------------+
| \>=    | is greater or equal to                                |
+--------+-------------------------------------------------------+
| ==     | is "already" equal to                                 |
+--------+-------------------------------------------------------+
| !=     | is not equal to                                       |
+--------+-------------------------------------------------------+
| &      | AND.                                                  |
|        |                                                       |
|        | Note that a `,` separating commands is an implied `&` |
+--------+-------------------------------------------------------+
| \|     | OR                                                    |
+--------+-------------------------------------------------------+

: Logical commands to use with filter()

```{r}
filter(rxp, 
       SVL.initial == 20.3)
filter(rxp, 
       SVL.initial == 20.3,
       Tail.initial == 8.5)
```

## AND `&` vs. OR `|`

-   Above we were looking for two values in two different columns, so `&` works

-   Sometimes we want to find two (or more) values in a single column

-   For example, we may want to subset the data to include all the `L` *and* `C` treatments in the `Pred` column

    -   Note that our goal is to have `L` ***AND*** `C`, but to accomplish this we must use the OR `|` operator

    -   The value in `Pred` can only be one thing in each row

    -   It can never be `L` and `C` at the same time

```{r}
filter(rxp, Pred == "L") |>
  as_tibble()
# 695 rows

filter(rxp,
       Pred == "L",
       Pred == "C")
# 0 rows. Values in Pred can never be C AND L at the same time

filter(rxp,
       Pred == "L" |
       Pred == "C") |>
  as_tibble()
# 2000+ rows
```

### More outliers

-   Couple of more plots to highlight other outliers

```{r}
plot(tmp$SVL.initial)
plot(tmp$Tail.initial)
```

-   There is one individual with an initial SVL \< 12

-   There also a couple of individuals with tails \> 15 mm

-   The author also says these should be removed as they are an "impossibly small" individual or "impossibly long" tails

-   We will "overwrite" the `tmp` object to only keep individuals which have SVL \> 12 and tails \< 15 mm

```{r}
tmp <- filter(tmp,
              SVL.initial > 12,
              Tail.initial < 15)
dim(tmp)
```

## Save the "cleaned" data

-   Now our `tmp` file has all the offending rows removed, and we can save it as a new `rxp_clean` object

```{r}
rxp_clean <- tmp
```

-   We are going to use this data again, so we can also save it as a .csv file

-   This will make it easier to load the "clean" data in future classes without having to go through all these steps again

```{r}
#| echo: false
write.csv(rxp_clean, 
          here::here("data/rxp_clean.csv"))
```

```{r}
#| eval: false
write.csv(rxp_clean, 
          "data/rxp_clean.csv")
```

# Summarizing and Manipulating data

## `dplyr` "verbs"

-   We will be using many helpful functions from the `dplyr` package, which is a part of the `tidyverse` that you already downloaded

-   `dplyr` has a number of "verbs" that are incredibly helpful for data exploration, manipulation, and summarization

-   We already saw one, `filter()`, which returns rows based on some criteria

    -   i.e. `filter(rxp, Pred == "L")`

-   The other verbs we will use are

    -   `select()` - keeps or discards columns based on name

    -   `mutate()` - adds new column(s)

    -   `summarize()` - takes many rows and returns one (i.e., a mean)

    -   `group_by()` - creates groups in the data to perform operations on

## Calculate group means

-   We are going to calculate means and estimate variation in our response variables

-   We want to do this by "groups"

    -   i.e., not usually interested in the average tail length across the full data set

    -   Usually more interested in knowing if the mean tail length in the various treatments are the same or different

### The pipe operator `%>%` or `|>`

-   We're going to take a brief detour

-   The pipe operator is a way of stringing together many commands/functions in a row

    -   `|>` is the "new" pipe

        -   This is a part of the base R system

        -   It is the modern way of piping and what you should learn/use

    -   `%>%` is the "old" pipe

        -   Should still work, and you will see it a lot in tutorials, message boards, etc.

        -   You should be aware of it

-   Pipes take what's on the left side and "pipe" it in as the first argument of the function on the right side

-   When you see a pipe, you should say "then"

-   For example, in the next bit of code, we are going to:

    -   Take the `rxp_clean` object THEN

    -   We are going to create groups by using the unique combinations of the `Res` and `Pred` columns THEN

    -   We are going to calculate the average (mean) value of `SVL.initial` for each group

```{r}
rp_means <- rxp_clean |>
  group_by(Res, Pred) |>
  summarize(SVL.mean = mean(SVL.initial))
rp_means
str(rp_means)
rp_means |>
  ungroup()|>
  str()
```

::: callout-tip
## Ungroup objects after \`summarize()\`

-   Note that the output of `rp_means` still has "groups" in it

-   You can remove the groups with the `ungroup()` function

-   It is recommended you do this to avoid weird behavior in the future

-   i.e., if you're working with a grouped object but don't realize it, the outputs can be unexpected
:::

### Reordering factors

-   Currently, `Pred` and `Res` are stored as a `Factor`

-   Recall that `Factor`'s have an "order" to them

-   What is the current order?

```{r}
levels(rxp_clean$Pred)
```

-   So Control ("C") comes before Lethal ("L") which comes before Non Lethal ("NL")

-   Let's say we want NL to be before L

-   We can accomplish by using the `mutate()` function

```{r}
rxp_clean <- rxp_clean |>
  mutate(Pred = factor(
    Pred, 
    levels = c("C", "NL", "L")))
levels(rxp_clean$Pred)
```

-   This looks a bit confusing so let's break it down

    -   We start by creating a "new" object called `rxp_clean`

    -   But we create that by starting with the "old" `rxp_clean` object THEN

    -   we create a "new" column called `Pred` using the `mutate()` function

    -   We create the "new" `Pred` column by starting with the "old" one

    -   We modify the "old" one to be a `Factor` column

    -   But we set the order we want inside of the `levels` argument

        -   Note that we use the `c()` command inside of the `levels` argument

        -   The `c()` function is short for "concatenate" which means "put together"

        -   Technically, we are creating a vector inside of the `levels` argument

        -   The order that we put things in the `c()` determine the order of the levels

## Calculate means and standard errors - `group_by()`, `summarize()` and `mutate()`

-   We will now perform a common workflow

-   We are going to group our data to calculate *summary* statistics

    -   mean, standard deviation (SD), and sample size (n)

-   We will then use that information to calculate an *inferential* statistic: Standard Error (SE)

```{r}
rp_means <- rxp_clean |>
  group_by(Res, Pred) |>
  summarize(SVL_mean = mean(SVL.initial),
            SVL_sd = sd(SVL.initial),
            SVL_n = n()) |>
  mutate(SVL_se = SVL_sd / sqrt(SVL_n)) |>
  ungroup()
rp_means
```

-   We are going to use the `rp_means` again later, so let's save that as a csv

```{r}
#| echo: false
write.csv(rp_means, 
          here::here("data/rxp_means.csv"))
```

```{r}
#| eval: false
write.csv(rp_means, 
          "data/rxp_means.csv")
```

# More plotting with `ggplot2`

-   The `plot()` function is useful for making simple graphs

-   `ggplot()` is a function which allows the flexibility of creating publication-quality graphics with ease

### The Grammar of Graphics

-   the "gg" in `ggplot` stands for grammar of graphics

-   GG has the following setup:

    -   `ggplot()` + `geom` + `optional layers`

    -   Not the use of the `+` sign to add layers

    -   Pipes do not work to add layers to a `ggplot()`

-   `ggplot()`

    -   Assign the data object using the `data =` argument

    -   Assign the aesthetics (i.e., the `x`, `y`) in the `aes()` function

-   Add a `geom` which defines the basic plot layout and style

    -   `geom_boxplot()` for a boxplot

    -   `geom_density()` for a density plot

    -   `geom_point()` for a scatter graph

    -   `geom_line()` to "connect the dots"

    -   Several other options

-   Other optional layers to customize the plot

    -   `labs()` to add/change plot labels

    -   `facet_wrap()` to split the plot into facets

    -   many options for changing color, fill, etc.

    -   `scales` to change the axis aspects

    -   `themes` to set consistent aspects

    -   Many other options

### Plotting one continuous variable

-   let's start making some plots

-   We will map one continuous column to either an `x` or `y` aesthetic

#### Histogram

```{r}
# on the x-axis
ggplot(data = rxp_clean,
       aes(x = SVL.final)) +
  geom_histogram()

# on the y-axis
ggplot(data = rxp_clean,
       aes(y = SVL.final)) +
  geom_histogram()
```

### Density plot

```{r}
ggplot(rxp_clean,
       aes(x = SVL.final)) +
  geom_density()
```

### One Continuous variable + one categorical variable

-   Map a categorical column (i.e., `Pred`) to a `color` or `fill` aesthetic

```{r}
ggplot(rxp_clean,
       aes(x = SVL.final,
           color = Pred)) +
  geom_histogram()

ggplot(rxp_clean,
       aes(x = SVL.final,
           fill = Pred)) +
  geom_histogram()
```

-   See the difference here between `color` (outline) and `fill` (internal color of bars)

-   Note that the bars are "stacked"

    -   It looks like the middle of the histograms are at \~ 250, 100, and 50 for C, NL and L, respectively

-   Change the `position = "identity"`

    -   And add an `alpha` argument to make them transparent

```{r}
#| message: false
ggplot(rxp_clean,
       aes(x = SVL.final,
           fill = Pred)) +
  geom_histogram(
    position = "identity",
    alpha = 0.5
  )
```

-   Peak of the red is \~150, not 250

-   If you want aesthetics to change based on data values you map that column in the `aes()` function

-   If you want to change values across everything, define it in the `geom` layer

```{r}
#| message: false
ggplot(rxp_clean,
       aes(x = SVL.final,
           fill = Pred)) +
  geom_histogram(
    position = "identity",
    alpha = 0.5,
    color = "black"
  )
```

-   Now all the bars have a black outline

### One Continuous variable + two categorical variable

-   So far, we have looked at how the final length varies across Predator treatments, but there is also the resource treatment

-   We can separate these with the `facet_wrap()` function

```{r}
#| message: false
ggplot(rxp_clean,
       aes(x = SVL.final,
           fill = Pred)) +
  geom_density() +
  facet_wrap(Pred~Res)
```

-   We can also define `y` as a categorical variable for another version

```{r}
#| message: false
ggplot(rxp_clean,
       aes(x = SVL.final,
           y = Res,
           fill = Pred)) +
  geom_boxplot() 
```

### Plotting summarized data with estimated errors

-   Let's switch gears slightly

-   Earlier, we calculated the group means and standard errors

-   Let's plot these using a couple of different methods

-   First, recall what the summarized data looks like

```{r}
rp_means
```

-   We have groups of unique combinations of `Res` and `Pred`

-   We also have the mean and SE stored in columns

-   Let's plot!

#### Bar plot using `geom_col` for column

```{r}
ggplot(rp_means,
       aes(x = Res, 
           fill = Pred, 
           y = SVL_mean,
           ymin = SVL_mean - SVL_se,
           ymax = SVL_mean + SVL_se)) +
  geom_col(position = "dodge") +
  geom_errorbar(position = position_dodge(0.9),
                width = 0.4) +
  coord_cartesian(ylim = c(15, 20))

```

### Plotting two continuous variables with and without categories

-   Let's go back to plotting the "raw" data

<!-- -->

-   Use `geom_point()` when we have two continuous variables in the `x` and `y` aesthetics

```{r}
ggplot(rxp_clean,
       aes(x = Mass.final, 
           y = SVL.final)) +
  geom_point()

# add color to points, make them small and transparent
# facet by Pred
# improve labels 
ggplot(rxp_clean,
       aes(x = Mass.final, 
           y = SVL.final,
           color = Res)) +
  geom_point(alpha = 0.3,
             size = 0.75) +
  facet_wrap(.~Pred) +
  labs(y = "Final SV Length (mm)",
       x = "Final mass (g)")
```

### Themes and inclusive color palettes

-   There a number of themes for `ggplot()`

    -   `theme_bw()` (my preference)

    -   `theme_light()`

    -   `theme_dark()`

    -   etc., Google "ggplot themes" for more

-   There is also the `viridis` color palette which has a number of colorblind-friendly palettes

    -   `scale_color_viridis...` and `scale_fill_viridis...` as appropriate

    -   the `â€¦` needs to either be:

        -   `_d` for discrete data

        -   `_c` for continuous dat

```{r}
#| message: false
ggplot(rxp_clean,
       aes(x = SVL.final,
           y = Res,
           fill = Pred)) +
  geom_boxplot() +
  theme_bw() +
  scale_fill_viridis_d()
```

-   Use `option` = A to H for different palettes

```{r}
ggplot(rxp_clean,
       aes(x = Mass.final, 
           y = SVL.final,
           color = Pred)) +
  geom_point(size = 1.5,
             alpha = 0.9) +
  theme_light() +
  scale_color_viridis_d(option = "A")
```

-   Note that it is hard to see the light color in `option = "A"`

::: callout-tip
## Start and stop for Viridis palettes

-   Sometime the "start" and "stop" point can be too light and dark, respectively

-   Particularly an issue when you only have two discrete values for your color/fill

-   You can modify the location of the start and stop points by using the `begin` and `end` arguments

-   The default is `begin=0` and `end=1`

    -   Note that it "begins" at the dark color and "ends" at the light color

-   Modify the above plot by setting the end value lower

```{r}
ggplot(rxp_clean,
       aes(x = Mass.final, 
           y = SVL.final,
           color = Pred)) +
  geom_point(size = 1.5,
             alpha = 0.9) +
  theme_light() +
  scale_color_viridis_d(option = "A", 
                        end = 0.8)
```

-   Now the lightest color is a peach/salmon color which is at least a little easier to see.
:::

# Summary

-   Always "look" at your data after you import it into R

    -   `str()`, `names()`, `dim()`

-   What columns do you have? What is the mode of each column?

-   For `character` and `Factor` data, what distinct values and/combinations do you have?

    -   `distinct(data.frame, col1_name, col2_name, etc.)`

-   Plot your data

    -   use `plot()` to see the distribution of response variables

    -   Use a second categorical/factor/character variable to see how distribution changes across groups

    -   Use a second continuous variable to see if there are relationships between the two

-   use `dplyr` to subset, modify, and summarize your data.

-   Use `ggplot()` to make publication-quality graphics

    -   Use of color, facets, transparency and axis labels for communicating data and results.

# Supplemental

## Data Info

::: callout-note
## Description of the RxP data. Adapted from Box 3.1 in [textbook](https://global.oup.com/academic/product/applied-statistics-with-r-9780197797341?cc=us&lang=en&).

-   The experiment had 96 mesocosm tanks arrayed in an open field in Gamboa, Panama.

    -   The Smithsonian runs a field station for tropical research here.

-   Investigated how variation in when a frog embryo hatches might affect its development to metamorphosis under various combinations of predators and resources.

-   Experimental treatments were as follows:

-   Hatching age: Early (four days post-oviposition) or late (six days post-oviposition). Note that oviposition = the act of laying eggs

-   Predators: Control (no predator), nonlethal (caged) dragonfly larvae, or lethal (free-swimming) dragonfly larvae.

-   Resources: Low (0.75 g) or high (1.5 g) food level, added every five days.

-   The mesocosms were spatially arranged in 8 blocks of 12 tanks each.

-   The three treatments were "fully crossed" - Each possible combination of treatments was created, resulting in 12 unique combinations of treatments. - The replicates were fully balanced across blocks and randomized within each block.

    -   Each block consisted of 1 tank from each of the 12 unique treatment combinations.

-   Each tank began with 50 tadpoles

-   The experiment ended when all tadpoles reached metamorphosis or had died.

-   Metamorphosis is a process that takes time.

-   Generally defined as the time from when the froglet's arms erupt from the body until when the tail is fully resorbed into the body. - The froglet may choose to leave the water early or late during that process.

-   Thus, several measurements were taken when the froglets first left the water, and several more when the tail was fully resorbed.

-   At metamorphosis, we measured the following response variables:

-   Age at hatching, in terms of both time since eggs were oviposited and time since the very first froglet crawled out of the water (defined as day 1).

-   Snout-vent length at emergence

-   Tail length at emergence.

-   Snout-vent length at completion of tail resorption.

-   Mass at completion of tail resorption.

-   Number of days needed for each metamorph to fully resorb the tail.

-   During the course of the experiment, disease broke out in 18 of the mesocosms containing nonlethal predators, and thus those tanks have been removed from the dataset.

-   Full citation for the article: Touchon, J. C., McCoy, M. W., Vonesh, J. R., and Warkentin, K. W. 2013. Effects of hatching plasticity carry over through metamorphosis in red-eyed treefrogs. *Ecology*. 94, no. 4: 850--860.
:::
